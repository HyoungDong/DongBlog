---
title: '06장 - 데이터 타입'
date: 2021-08-30 14:04:00
category: '모던 자바스크립트 Deep Dive'
draft: false
---

## **7개의 타입**

- 원시 타입
    - 숫자 타입
    - 문자열 타입
    - 불리언 타입
    - null 타입
    - undefined 타입
    - 심볼 타임
- 객체 타입
    - 객체, 함수, 배열 등 원시 타입을 제외한 모든 것

### **숫자 타입 (number)**

자바 스크립트는 모든 수를 실수로 처리하며 정수, 실수등 각각의 숫자 타입이 존재하지 않고 `숫자 타입(number)`

하나만 존재한다.

```jsx
console.log(1 === 1.0) // true
// 숫자 타입은 모두 실수로 처리됨
```

자바스크립트는 2진수, 8진수, 16진수를 표현하기 위한 데이터 타입을 제공하지 않기 때문에 이들 값을 참조하면 모두 10진수로 해석된다.

```jsx
var binary = 0b01000001;
var octal = 0o101;
var hex = 0x41;

console.log(binary); // 65
console.log(octal); // 65
console.log(hex); // 65
console.log(binary === octal); // true 
```

자바스크립트의 숫자 타입은 추가적으로 세가지 특별한 값이 있다.

**Infinity** : 양의 무한대

**-Infinity** : 음의 무한대

**NaN** : 산술 연산 불가(not-a-number)

```jsx
console.log(10 / 0); // Infinity 0 으로 나누어도 에러발생 X
console.log(10 / -0); // -Infinity
console.log(1 * '도레미'); // NaN
```

### **문자열 타입**

따옴표로 감싸진 텍스트를 문자열으로 한다.

```jsx
var name = '도레미';
```

문자열은 원시 타입이며, 변경 불가능한 값(immutable) 이다.

재할당이 안된다는 소리는 아니다.

```jsx
var name = '도레미';
name = '도레미파';
```

변경 불가능한 값인데 재할당이 가능한 이유는 자바스크립트는 재할당시 원래 메모리에 있던 값을 바꾸는 것이 아니

라 새로운 메모리를 확보한 후 그곳에 새로 재할당된 값을 저장한다. 즉, 변경이 일어나지 않는다.

```jsx
var name = '도레미';
name[0] = '파';

console.log(name); // 도레미
```

배열 index에 접근하여 값을 변경하려 하면, 오류는 발생하지 않지만 변경 불가능한 값이기 때문에 기존값 그대로

출력되는 것을 볼 수 있다.

### **템플릿 리터럴**

ES6 부터 도입된 아주 유용한 기능이다.

**` `** (백틱) 을 사용해 표현한다. 

```jsx
var temp = `Hello 
World`

// 일반 문자열에서 되지 않는 줄바꿈이 가능하다. 모든 공백도 있는 그대로 적용된다.

var result = `1 + 2 = ${1+2}`;
// 자바스크립트의 표현식이 삽입 가능하다. 템플릿 리터럴이 많이 쓰이는 이유!!
```



### **불리언 타입**

우리가 흔히 알고있는 논리척 참, 거짓 `true, false`  

### **undefined 타입**

이 타입의 값은 undefined 가 유일하다.

undefined 는 아직 값이 할당된적이 없음을 의미한다.

### **null 타입**

이 타입의 값은 null 이 유일하다.

undefined 와 다른점은 undefined 는 값이 할당된적이 없는 암묵적 초기화 값이고,

null 은 사용자가 특정 변수에 값이 없다는 것을 의도적으로 명시 하기위해 할당한 값 이다.

사용자가 특정 변수에 null 값을 할당하게 되면 이전에 참조하던 값을 더이상 참조하지 않겠다는 의미다.

```jsx
console.log(typeof null); // object

// 이는 초기 자바스크립트 버전의 버그이다. null은 객체가 아닌 원시 타입임
```
<br/>

### **심벌 타입 & 객체 타입**

추후 챕터에서 다룰 예정.

<br/>

## **데이터 타입이 필요한 이유**

<br/>

### **데이터 타입에 의한 메모리 공간의 확보**
<br/>

메모리에 값을 저장할 때 몇 바이트의 메모리가 필요한지 결정해야 한다.

변수에 할당되는 값의 데이터 타입에 따라 확보해야 할 메모리 공간의 크기가 결정됨.

### **데이터 타입이 의한 메모리 참조**
<br/>

메모리에 저장된 값을 읽을 때 몇 바이트의 메모리를 읽어야 할지 결정해야 한다.

`심벌 테이블` 이라는 자료 구조를 통해 변수(식별자)를 키로 바인딩된 값의 메모리 주소, 데이터 타입, 스코프 등을 관리하기 때문에, 특정 변수를 참조하면 어떤 데이터 타입인지 알 수있고 그 타입에 맞는 크기만큼의 메모리를 읽어 들인다.

### **데이터 타입에 의한 값의 해석**
<br/>

메모리에서 읽어 들인 2진수를 어떻게 해석할지 결정해야 한다.

모든 값은 2진수로 저장된다.

같은 2진수 라도 데이터 타입에 따라 다르게 해석될 수 있다.

## **정적 타입 & 동적 타입**
<br/>

### **정적 타입**
<br/>

변수 선언 시 데이터 타입을 사전에 선언하고 컴파일 시점에 타입 체크를 수행한다.

**(사전 선언 시 변수의 타입이 정해져있음)**

타입 체크를 통과하지 못했다면 에러를 발생시키고 프로그램의 실행 자체를 막는다.

타입을 강제함으로써 런타임에 발생하는 에러를 줄일 수 있다.

**`신뢰성이 높지만 유연성이 떨어진다.`**

### **동적 타입**
<br/>

변수 선언 시 타입을 선언하지 않는다.

변수에 어떠한 데이터 타입의 값이라도 자유롭게 할당할 수 있다.

**(런타임에 변수 값 할당에 의해 타입이 결정(추론) 됨)**

재할당에 의해 변수의 타입은 계속해서 동적으로 변할 수 있음.

숫자 타입의 변수가 필요한 함수에 문자 타입의 변수가 전달될 수 있다.

이런 경우 오류가 발생하거나 의도한 결과를 얻지 못할 수 도 있다.

수행전에 변수들의 데이터 타입을 `typeof` 로 일일이 확인하여 어떤 상황일때만 수행하라고 조건을 걸어 줄 수 있지만,

이는 매우 번거로울뿐더러 코드의 양도 증가한다.

**`유연성이 높지만 신뢰성이 떨어진다.`**

### **변수 사용 시 주의할 사항**
<br/>

- 꼭 필요한 경우에만 최소한의 변수만 사용하자
- 변수의 유효 범위를 최대한 좁게 만들어 사용하자
- 전역 변수는 최대한 사용하지 않는다
- `const` 키워드로 상수를 사용하여 값의 재할당을 억제하여 부작용을 최소화 하자
- 변수의 목적이나 의미를 파악할 수 있도록 변수의 이름을 짓자