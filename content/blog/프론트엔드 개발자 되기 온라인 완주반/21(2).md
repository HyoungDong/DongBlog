---
title: 'Sass(2)'
date: 2021-06-10 19:00:00
category: '프론트엔드 개발자 되기 온라인 완주반'
draft: false
---

<br/>


## **SCSS 문법 - `재활용 - 인수(Arguments)`**
- Mixin은 함수(Functions)처럼 인수(Arguments)를 가질 수 있습니다.

```scss
// SCSS
@mixin 믹스인이름($매개변수) {
  스타일;
}
@include 믹스인이름(인수);

// Sass
=믹스인이름($매개변수)
  스타일

+믹스인이름(인수)
```
```scss
@mixin dash-line($width, $color) {
  border: $width dashed $color;
}

.box1 { @include dash-line(1px, red); }
.box2 { @include dash-line(4px, blue); }
```
```css
.box1 {
  border: 1px dashed red;
}
.box2 {
  border: 4px dashed blue;
}
```
### **인수의 기본값 설정**
- 인수(argument)는 기본값(default value)을 가질 수 있습니다.
- `@include` 포함 단계에서 별도의 인수가 전달되지 않으면 기본값이 사용됩니다.

```scss
@mixin 믹스인이름($매개변수: 기본값) {
  스타일;
}
```
```scss
@mixin dash-line($width: 1px, $color: black) {
  border: $width dashed $color;
}

.box1 { @include dash-line; }
.box2 { @include dash-line(4px); }
```
```css
.box1 {
  border: 1px dashed black;
}
.box2 {
  border: 4px dashed black;
}
```

### **키워드 인수(Keyword Arguments)**
- Mixin에 전달할 인수를 입력할 때 명시적으로 키워드(변수)를 입력하여 작성할 수 있습니다.
- 별도의 인수 입력 순서를 필요로 하지 않아 편리하게 작성할 수 있습니다.
- 작성하지 않은 인수가 적용될 수 있도록 기본값을 설정해 주는 것이 좋습니다.

```scss
@mixin 믹스인이름($매개변수A: 기본값, $매개변수B: 기본값) {
  스타일;
}

@include 믹스인이름($매개변수B: 인수);
```

```scss
@mixin position(
  $p: absolute,
  $t: null,
  $b: null,
  $l: null,
  $r: null
) {
  position: $p;
  top: $t;
  bottom: $b;
  left: $l;
  right: $r;
}

.absolute {
  // 키워드 인수로 설정할 값만 전달
  @include position($b: 10px, $r: 20px);
}
.fixed {
  // 인수가 많아짐에 따라 가독성을 확보하기 위해 줄바꿈
  @include position(
    fixed,
    $t: 30px,
    $r: 40px
  );
}
```
```css
.absolute {
  position: absolute;
  bottom: 10px;
  right: 20px;
}
.fixed {
  position: fixed;
  top: 30px;
  right: 40px;
}
```

### **가변 인수(Variable Arguments)**
- 입력할 인수의 개수가 불확실한 경우가 있습니다. 그럴 경우 가변 인수를 사용할 수 있습니다.
- 가변 인수는 매개변수 뒤에 ...을 붙여줍니다.

**매개변수에 `...` 을 사용**
```scss
@mixin 믹스인이름($매개변수...) {
  스타일;
}

@include 믹스인이름(인수A, 인수B, 인수C);
```
```scss
// 인수를 순서대로 하나씩 전달 받다가, 3번째 매개변수($bg-values)는 인수의 개수에 상관없이 받음
@mixin bg($width, $height, $bg-values...) {
  width: $width;
  height: $height;
  background: $bg-values;
}

div {
  // 위의 Mixin(bg) 설정에 맞게 인수를 순서대로 전달하다가 3번째 이후부터는 개수에 상관없이 전달
  @include bg(
    100px,
    200px,
    url("/images/a.png") no-repeat 10px 20px,
    url("/images/b.png") no-repeat,
    url("/images/c.png")
  );
}
```
```css
div {
  width: 100px;
  height: 200px;
  background: url("/images/a.png") no-repeat 10px 20px,
              url("/images/b.png") no-repeat,
              url("/images/c.png");
}

```

**전달할 인수에 `...` 사용**
```scss
@mixin font(
  $style: normal,
  $weight: normal,
  $size: 16px,
  $family: sans-serif
) {
  font: {
    style: $style;
    weight: $weight;
    size: $size;
    family: $family;
  }
}
div {
  // 매개변수 순서와 개수에 맞게 전달 (list)
  $font-values: italic, bold, 16px, sans-serif;
  @include font($font-values...);
}
span {
  // 필요한 값만 키워드 인수로 변수에 담아 전달 (map)
  $font-values: ($style: italic, $size: 22px);
  @include font($font-values...);
}
a {
  // 필요한 값만 키워드 인수로 전달 (map)
  @include font(($weight: 900, $family: monospace)...);
}
```
```css
div {
  font-style: italic;
  font-weight: bold;
  font-size: 16px;
  font-family: sans-serif;
}
span {
  font-style: italic;
  font-weight: normal;
  font-size: 22px;
  font-family: sans-serif;
}
a {
  font-style: normal;
  font-weight: 900;
  font-size: 16px;
  font-family: monospace;
}
```


<br/>


## **SCSS 문법 - `재활용 - @content`**
- 선언된 Mixin에 `@content이` 포함되어 있다면 해당 부분에 원하는 **스타일 블록** 을 전달할 수 있습니다.
- 이 방식을 사용하여 기존 Mixin이 가지고 있는 기능에 선택자나 속성 등을 추가할 수 있습니다.

```scss
@mixin 믹스인이름() {
  스타일;
  @content;
}

@include 믹스인이름() {
  // 스타일 블록
  스타일;
}
```
```scss
@mixin icon($url) {
  &::after {
    content: $url;
    @content;
  }
}
.icon1 {
  // icon Mixin의 기존 기능만 사용
  @include icon("/images/icon.png");
}
.icon2 {
  // icon Mixin에 스타일 블록을 추가하여 사용
  @include icon("/images/icon.png") {
    position: absolute;
  };
}
```
```css
.icon1::after {
  content: "/images/icon.png";
}
.icon2::after {
  content: "/images/icon.png";
  position: absolute;
}
```
- Mixin에게 전달된 스타일 블록은 Mixin의 범위가 아니라 스타일 블록이 정의된 범위에서 평가됩니다.

```scss
$color: red;

@mixin colors($color: blue) {
  // Mixin의 범위
  @content;
  background-color: $color;
  border-color: $color;
}

div {
  @include colors() {
    // 스타일 블록이 정의된 범위
    // 이 범위에서의 $color 값은 전역 변수의 값인 red 입니다.
    color: $color;
  }
}
```
```css
div {
  color: red;
  background-color: blue;
  border-color: blue;
}
```

<br/>


## **SCSS 문법 - `확장(Extend)`**
- 특정 선택자가 다른 선택자의 모든 스타일을 가져야하는 경우가 종종 있습니다.
- 이럴 경우 선택자의 확장 기능을 사용할 수 있습니다.

```scss
@extend 선택자;
```
```scss
.btn {
  padding: 10px;
  margin: 10px;
  background: blue;
}
.btn-danger {
  @extend .btn;
  background: red;
}
```
```css
.btn, .btn-danger {
  padding: 10px;
  margin: 10px;
  background: blue;
}
.btn-danger {
  background: red;
}
```

- 결과를 보면 `,` 로 구분하는 `다중 선택자(Multiple Selector)` 가 만들어졌습니다.
- 결과적으로 `확장(Extend)` 기능은 무해하거나 혹은 유익할 수도 있지만 그만큼 **부작용을 가지고 있을 수 있습니다.**
따라서 **확장은 사용을 권장하지 않으며**, 위에서 살펴본 **Mixin을 대체 기능**으로 사용하세요.

<br/>


## **SCSS 문법 - `함수(Functions)`**
- 자신의 함수를 정의하여 사용할 수 있습니다.
- 함수와 Mixins은 거의 유사하지만 반환되는 내용이 다릅니다.
- Mixin은 위에서 살펴본 대로 지정한 스타일(Style)을 반환합니다.
- 함수는 보통 `연산된(Computed) 특정 값`을 `@return` 지시어를 통해 반환합니다.
- 함수는 `@include` 같은 별도의 지시어 없이 사용하기 때문에 내가 `지정한 함수` 와 `내장 함수(Built-in Functions)` 의 이름이 충돌할 수 있습니다. 따라서 내가 지정한 함수에는 별도의 접두어를 붙여주는 것이 좋습니다.



```scss
// Mixins
@mixin 믹스인이름($매개변수) {
  스타일;
}

// Functions
@function 함수이름($매개변수) {
  @return 값
}
```
- Mixin은 사용 시 `@include` 지시어를 사용합니다.
- 함수는 사용 시 함수이름으로 바로 사용합니다.
```scss
// Mixin
@include 믹스인이름(인수);

// Functions
함수이름(인수)
```

```scss
$max-width: 980px;

@function columns($number: 1, $columns: 12) {
  @return $max-width * ($number / $columns)
}

.box_group {
  width: $max-width;

  .box1 {
    width: columns();  // 1
  }
  .box2 {
    width: columns(8);
  }
  .box3 {
    width: columns(3);
  }
}
```
```css
.box_group {
  /* 총 너비 */
  width: 980px;
}
.box_group .box1 {
  /* 총 너비의 약 8.3% */
  width: 81.66667px;
}
.box_group .box2 {
  /* 총 너비의 약 66.7% */
  width: 653.33333px;
}
.box_group .box3 {
  /* 총 너비의 25% */
  width: 245px;
}
```

<br/>


## **SCSS 문법 - `if (함수)`**
- 조건의 값(`true, false`)에 따라 두 개의 표현식 중 하나만 반환합니다.
- **조건부 삼항 연산자(conditional ternary operator)** 와 비슷합니다.
- 조건의 값이 `true` 이면 표현식1을 반환합니다.
- 조건의 값이 `false` 이면 표현식2를 반환합니다.

```
if(조건, 표현식1, 표현식2)
```
```scss
$width: 555px;
div {
  width: if($width > 300px, $width, null);
}
```
```scss
div {
  width: 555px;
}
```

<br/>


## **SCSS 문법 - `@if (지시어)`**
- `@if` 지시어는 조건에 따른 분기 처리가 가능하며, `if 문(if statements)` 과 유사합니다.

```scss
// @if
@if (조건) {
  /* 조건이 참일 때 구문 */
}

// @if @else
@if (조건) {
  /* 조건이 참일 때 구문 */
} @else {
  /* 조건이 거짓일 때 구문 */
}

// @if @else if
@if (조건1) {
  /* 조건1이 참일 때 구문 */
} @else if (조건2) {
  /* 조건2가 참일 때 구문 */
} @else {
  /* 모두 거짓일 때 구문 */
}
```
- Sass의 내장 함수 **`unitless()`** 는 숫자에 단위가 있는지 여부를 반환합니다.
```scss
//if 예제

@mixin pCenter($w, $h, $p: absolute) {
  @if
    $p == absolute
    or $p == fixed
    or not $p == relative
    or not $p == static
  {
    width: if(unitless($w), #{$w}px, $w);
    height: if(unitless($h), #{$h}px, $h);
    position: $p;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    margin: auto;
  }
}

.box1 {
  @include pCenter(10px, 20px);
}
.box2 {
  @include pCenter(50, 50, fixed);
}
.box3 {
  @include pCenter(100, 200, relative);
}
```
```css
.box1 {
  width: 10px;
  height: 20px;
  position: absolute;
  top: 0;
  bottom: 0;
  left: 0;
  right: 0;
  margin: auto;
}

.box2 {
  width: 50px;
  height: 50px;
  position: fixed;
  top: 0;
  bottom: 0;
  left: 0;
  right: 0;
  margin: auto;
}
```

<br/>


## **SCSS 문법 - `@for`**
- `@for` 는 스타일을 반복적으로 출력합니다.
- for 문과 유사합니다.
- `@for` 는 `through` 를 사용하는 형식과 `to` 를 사용하는 형식으로 나뉩니다.

```scss
// through
// 종료 만큼 반복
@for $변수 from 시작 through 종료 {
  // 반복 내용
}

// to
// 종료 직전까지 반복
@for $변수 from 시작 to 종료 {
  // 반복 내용
}
```
```scss
// 1부터 3번 반복
@for $i from 1 through 3 {
  .through:nth-child(#{$i}) {
    width : 20px * $i
  }
}

// 1부터 3 직전까지만 반복(2번 반복)
@for $i from 1 to 3 {
  .to:nth-child(#{$i}) {
    width : 20px * $i
  }
}
```
```css
.through:nth-child(1) { width: 20px; }
.through:nth-child(2) { width: 40px; }
.through:nth-child(3) { width: 60px; }

.to:nth-child(1) { width: 20px; }
.to:nth-child(2) { width: 40px; }
```

<br/>


## **SCSS 문법 - `@each`**
- `@each` 는 `List` 와 `Map` 데이터를 순회 할 때 사용합니다.
- for in 문과 유사합니다.

```scss
@each $변수 in 데이터 {
  // 반복 내용
}
```
```scss
// List Data
$fruits: (apple, orange, banana, mango);

.fruits {
  @each $fruit in $fruits {
    li.#{$fruit} {
      background: url("/images/#{$fruit}.png");
    }
  }
}
```
```css
.fruits li.apple {
  background: url("/images/apple.png");
}
.fruits li.orange {
  background: url("/images/orange.png");
}
.fruits li.banana {
  background: url("/images/banana.png");
}
.fruits li.mango {
  background: url("/images/mango.png");
}
```

- 반복마다 Index 값이 필요하다면 다음과 같이 index() 내장 함수를 사용할 수 있습니다.

```scss
$fruits: (apple, orange, banana, mango);
// index(list , data);
.fruits {
  @each $fruit in $fruits {
    $i: index($fruits, $fruit);
    li:nth-child(#{$i}) {
      left: 50px * $i;
    }
  }
}
```
```css
.fruits li:nth-child(1) {
  left: 50px;
}
.fruits li:nth-child(2) {
  left: 100px;
}
.fruits li:nth-child(3) {
  left: 150px;
}
.fruits li:nth-child(4) {
  left: 200px;
}
```
- 동시에 여러 개의 List 데이터를 반복 처리할 수도 있습니다.
단, 각 데이터의 Length가 같아야 합니다.

```scss
$apple: (apple, korea);
$orange: (orange, china);
$banana: (banana, japan);

@each $fruit, $country in $apple, $orange, $banana {
  .box-#{$fruit} {
    background: url("/images/#{$country}.png");
  }
}
```
```css
.box-apple {
  background: url("/images/korea.png");
}
.box-orange {
  background: url("/images/china.png");
}
.box-banana {
  background: url("/images/japan.png");
}
```

- Map 데이터를 반복할 경우 하나의 데이터에 두 개의 변수가 필요합니다.

```scss
@each $key변수, $value변수 in 데이터 {
  // 반복 내용
}
```
```scss
$fruits-data: (
  apple: korea,
  orange: china,
  banana: japan
);

@each $fruit, $country in $fruits-data {
  .box-#{$fruit} {
    background: url("/images/#{$country}.png");
  }
}
```
```css
.box-apple {
  background: url("/images/korea.png");
}
.box-orange {
  background: url("/images/china.png");
}
.box-banana {
  background: url("/images/japan.png");
}
```

- `@each` 를 통하여 `map` 을 순회할 때 `index` 가 필요한 경우엔 `map` 의 `key, value` 중 하나를 `list` 로 바꾸어 주는 내장함수를 통하여 추출할 수 있습니다.
- `map-keys()` 는 `map` 에서 `key` 들 만을 뽑아 `list` 형태로 반환 합니다.
- `map-values()` `map` 에서 `value` 들 만을 뽑아 `list` 형태로 반환 합니다.

```scss
$fruits-data : {
    apple : korea,
    orange : china,
    banana : japan
}

$key-list : map-keys($fruits-data);
// (apple, orange, banana)
$value-list : map-values($fruits-data);
// (korea, china, japan)

@each $fruit, $country in $fruits-data {
   $key-index : index($key-list, fruit);
   $value-index : index($value-list, country);
  .box-#{$fruit} {
    background: url("/images/#{$country}.png");
  }
}
```

<br/>


## **SCSS 문법 - `@while`**
- @while은 조건이 false로 평가될 때까지 내용을 반복합니다.
- while 문과 유사하고 잘못된 조건으로 인해 컴파일 중 무한 루프에 빠질 수 있습니다.
- 사용을 권장하지 않습니다.

```scss
@while 조건 {
  // 반복 내용
}
```
```scss
$i: 6;

@while $i > 0 {
  .item-#{$i} {
    width: 2px * $i;
  }
  $i: $i - 2;
}
```
```css
.item-6 { width: 12px; }
.item-4 { width: 8px; }
.item-2 { width: 4px; }
```

<br/>


## **SCSS 문법 - `내장 함수(Built-in Functions)`**
- Sass에서 기본적으로 제공하는 내장 함수에는 많은 종류가 있습니다.
- [Sass Built-in Functions](https://sass-lang.com/documentation/modules) 에서 모든 내장 함수를 확인할 수 있습니다.
- `[]` 는 선택 가능한 인수(argument)입니다. `[]` 가 없는 인수는 필수적으로 입력 하여야 합니다.
- `Zero-based numbering` 을 사용하지 않습니다.

### **색상(RGB / HSL / Opacity) 함수**
- **mix($color1, $color2)** : 두 개의 색을 섞습니다.

- **lighten($color, $amount)** : 더 밝은색을 만듭니다.

- **darken($color, $amount)** : 더 어두운색을 만듭니다.

- **saturate($color, $amount)** : 색상의 채도를 올립니다.

- **desaturate($color, $amount)** : 색상의 채도를 낮춥니다.

- **grayscale($color)** : 색상을 회색으로 변환합니다.

- **invert($color)** : 색상을 반전시킵니다.

- **rgba($color, $alpha)** : 색상의 투명도를 변경합니다.

- **opacify($color, $amount) / fade-in($color, $amount)** : 색상을 더 불투명하게 만듭니다.

- **transparentize($color, $amount) / fade-out($color, $amount)** : 색상을 더 투명하게 만듭니다.

### **문자(String) 함수**
- **unquote($string)** : 문자에서 따옴표를 제거합니다.

- **quote($string)** : 문자에 따옴표를 추가합니다.

- **str-insert($string, $insert, $index)** : 문자의 index번째에 특정 문자를 삽입합니다.

- **str-index($string, $substring)** : 문자에서 특정 문자의 첫 index를 반환합니다.

- **str-slice($string, $start-at, [$end-at])** : 문자에서 특정 문자(몇 번째 글자부터 몇 번째 글자까지)를 추출합니다.

- **to-upper-case($string)** : 문자를 대문자를 변환합니다.

- **to-lower-case($string)** : 문자를 소문자로 변환합니다.


### **숫자(Number) 함수**
- **percentage($number)** : 숫자(단위 무시)를 백분율로 변환합니다.

- **round($number)** : 정수로 반올림합니다.

- **ceil($number)** : 정수로 올림합니다.

- **floor($number)** : 정수로 내림(버림)합니다.

- **abs($number)** : 숫자의 절대 값을 반환합니다.

- **min($numbers…)** : 숫자 중 최소 값을 찾습니다.

- **max($numbers…)** : 숫자 중 최대 값을 찾습니다.

- **random()** : 0 부터 1 사이의 난수를 반환합니다.